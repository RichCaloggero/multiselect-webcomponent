<template id="treeTemplate">
<style>
.screen-reader-only {
position: absolute;
overflow: none;
left: -9999; top: -9999;
}

</style>

<div class="tree" role="group">
<label>
<span class="text"></span>

<ul class="treeNodes">
<slot select="li"></slot>
</ul>
</label>

<div class="status screen-reader-only" aria-live="polite"></div>
</div>
</template>

<script src="domTraversal.js"></script>
<script src="keyboardNavigation.js"></script>

<script>
"use strict";
var template = document.querySelector('#treeTemplate');

(function() {
var searchTimer = null;
var searchText = "";
var filterText = "";

customElements.define ("x-tree", class extends HTMLElement {
constructor () {
super ();
//debug ("x-autocomplete element created");
} // constructor

connectedCallback () {
this.init();
this.render();
} // connectedCallback

init () {
this.initOptions();

this._filterText = "";
this._root = this.createRootElement();
this._container = this._root.querySelector('.tree');
this._labelText = this._root.querySelector('label .text');
this._treeNodes = this._root.querySelector(".treeNodes");
this._status = this._root.querySelector('.status');

this._labelText.textContent = this._options.label;
this._status.classList.toggle ("screen-reader-only", !this._options.showStatusMessages);

} // init

initOptions () {
this._options = {
label: this.getAttribute("label") || '',
showStatusMessages: this.getAttribute("showStatusMessages")
}; // options
} // initOptions

createRootElement () {
var root = this.attachShadow({delegatesFocus: true, mode: "open"});
var content = template.content.cloneNode(true);

/*if (window.ShadowDOMPolyfill) {
WebComponents.ShadowCSS.shimStyling(content, 'x-autocomplete');
}
*/

root.appendChild(content);

//debug ("- root created");
return root;
} // createRootElement

render () {
this.attachHandlers();

//debug ("render complete.");
} // render

attachHandlers () {
var self = this;

this._treeNodes.addEventListener("click", this.clickTree.bind(this));

this.currentItem = keyboardNavigation(this._treeNodes, {
type: "tree",
activeNode: ":not([hidden])",

actions: {
escape: this.escape.bind(this),
toggleSelected: this.toggleSelected.bind(this),
value: this.value.bind(this)
}, // actions

keymap: {
escape: ["Escape"],
toggleSelected: [" "],
value: ["Enter"],
up: ["ArrowLeft"], down: ["ArrowRight"]
} // keymap
}); // keyboardNavigation

//debug ("currentItem: ", this.currentItem, " value = ", this.currentItem().outerHTML);
} // attachHandlers


handleListFilter () {
this.filterList (this._typeahead.value);
} // handleListFilter

filterList (text) {
this.restoreList ();

if (text) {
text = text.toLowerCase().trim();
debug ("filter: ", text);
this.allElements().forEach (function (element) {
var elementText = element.textContent.toLowerCase().trim();
//debug ("- ", elementText.startsWith(text), elementText);
if (!elementText.startsWith(text)) element.setAttribute ("hidden", "true");
}); // forEach
} // if

this.displayItemCount ();
} // filterList 


clickTree (e) {
var item = e.target;
while(item && nodeName(item) !== "li") {
item = item.parentNode;
}

this.toggleSelected(item);
}; // clickTree

escape () {
this.unselectAll();
} // escape

toggleSelected(node) {
if (this.isSelected(node)) unselectNode (node);
else selectNode (node);

this.fireChangedEvent ();
} // toggleSelected

/// elements and items

selectedNodes () {
return Array.from(this.querySelectorAll("li[selected]"));
} // selectedElements

allNodes () {
return Array.from(this.querySelectorAll("[role=treeitem]"));
} // allNodes

selectAll () {
this.allNodes().forEach (e => this.selectNode(e));
} // selectAll

unselectAll () {
this.allNodes().forEach (e => this.unselectNode(e));
} // unselectAll


fireChangeEvent () {
var event = new CustomEvent("change");
this.dispatchEvent(event);
};


treeNodes (selector) {
selector = selector || ":not([hidden])";
return Array.from(this.querySelectorAll(selector));
}; // treeNodes


attributeChangedCallback (optionName, oldValue, newValue) {
this._options[optionName] = newValue;
};


valueOf (node) {
if (! node) return "";
return (node.hasAttribute("value"))?
node.getAttribute("value") : node.textContent;
} // nodeValue

value () {
return this.selectedNodes()
.map (e => valueOf(e));
} // value


statusMessage (text) {
this._status.textContent = text;
} // statusMessage

}); // custom element





})();

alert	 ("tree component loaded");
</script>

